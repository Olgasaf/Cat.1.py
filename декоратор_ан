def do_it_twice(func):  # создаём декоратор
   def wrapper(*args, **kwargs):  # эта функция wrapper выступает, как обёртка/шаблон для декорирования рабочей функции say_word. [*args, **kwargs] - аргументы, которые могут быть в рабочей функции, в данном случае say_word.
       # В тело функции wrapper добавляем нужный код для рабочей функции say_word - т.е. какое-то дополнение,
       # которое нужно применить к работе этой функции, при этом оно не изменит работу кода внутри самой функции say_word.
       for i in range(3):  # в данном случае мы хотим, чтобы функция say_word сработала 3 раза подряд!
           func(*args, **kwargs)
   return wrapper

# добавляем наш декоратор перед функцией, которую нужно декорировать (say_word) в виде синтетического сахара,
# т.е. ставим в начале знак @:
@do_it_twice
def say_word(word):  # декорируемая/рабочая функция
# тело декорируемой функции, в которой м.б. прописан любой код. В данном случае функция выводит любое указанное в ней слово.
    print(word)

say_word("Привет!")  # Вызываем нашу рабочую функцию say_word с указанием в аргументе соответствующего значения. В данном случае текста...
# >> out print:
# Привет!
# Привет!
# Привет!


# И сразу пример для второй "рабочей" функции, для понимания логики применения декоратора...
@do_it_twice  # использование декоратора для другой рабочей функции
def number(x, y):
    print(x ** y)
number(3, 4)
# >> out print:
# 81
# 81
# 81
# Без применения декоратора @do_it_twice, функция number сработала бы только один раз.
